---
layout: post
title: 2026-01-05(Mon)
date: 2026-01-05 10:00:00 +0900
categories: post
tags:
  - jcef
  - til
---

# Crashing with JCEF in Jetpack Compose for Desktop Applications when closing a JCEF Composable via Keyboard Shortcut
For reasons unknown, executing `browser.close(true)` from JCEF via a keyboard shortcut causes a crash.
More precisely, it's not an exception that terminates the application; the HotSpot VM itself is crashing.

```
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x00007ffb6a9cb326, pid=18484, tid=6016
#
# JRE version: OpenJDK Runtime Environment Corretto-21.0.5.11.1 (21.0.5+11) (build 21.0.5+11-LTS)
# Java VM: OpenJDK 64-Bit Server VM Corretto-21.0.5.11.1 (21.0.5+11-LTS, mixed mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, windows-amd64)
# Problematic frame:
# C  [awt.dll+0xdb326]
#
# No core dump will be written. Minidumps are not enabled by default on client versions of Windows
```

The reason for `browser.close(true)` is that after commenting out suspicious code lines one by one to confirm the reproduction, we identified this function call as the cause.

## Relying on AI
After providing Gemini3 with a portion of the HotSpot JVM error dump for investigation, it suggested a high possibility of interference between AWT and JCEF.
It then offered several solutions. The most straightforward one, wrapping `browser.close` with `SwingUtilities.invokeLater`, was tested.

```kotlin
SwingUtilities.invokeLater(Runnable {
    browser.close(true)
})
```

The crash completely stopped. This is excellent. While reaching this solution was partly due to my own efforts in directly investigating the cause, I cannot help but praise the capabilities of Gemini3.

Below is the summary from Gemini3.

----
# Gemini3 said
The core of this problem lies in a synchronization mismatch between JCEF (the native C++ world) and AWT/Swing (the Java GUI thread).

## Why `invokeLater` Solved It
The moment the keyboard shortcut event occurs, AWT is in a very delicate state of processing key input. Calling `browser.close(true)` during this exact moment causes JCEF to immediately attempt to discard the native window handle (like HWND).

However, AWT tries to continue its rendering and focus control on the window that should have been there, leading to a crash by reading/writing to memory addresses that no longer exist (EXCEPTION_ACCESS_VIOLATION).

By using `SwingUtilities.invokeLater`, the JCEF destruction process was deferred until immediately after the current AWT processing finishes, which proved to be the decisive factor.

## Tips for the Future: Coexistence with Skiko
If you encounter instability again in the future as your Compose UI grows, it will be smoother for troubleshooting if you keep the following configuration in mind:

- JCEF: Always relies on AWT's native windows.
- Compose (Skiko): Operates with its own rendering loop (Rendering Thread).

Solution: Always serialize interactions at the junction point between the two (like close operations or resizing, as in this case) by going through the Event Dispatch Thread (EDT).

